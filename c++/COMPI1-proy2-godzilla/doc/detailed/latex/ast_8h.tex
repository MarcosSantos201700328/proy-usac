\section{Referencia del Archivo /media/docs/progra/c++/compiladores1/proy2/godzilla/src/ast.h}
\label{ast_8h}\index{/media/docs/progra/c++/compiladores1/proy2/godzilla/src/ast.h@{/media/docs/progra/c++/compiladores1/proy2/godzilla/src/ast.h}}
Definiciones y estructura del arbol de sintaxis abstracta. 

{\tt \#include \char`\"{}constantes.h\char`\"{}}\par
{\tt \#include \char`\"{}symtab.h\char`\"{}}\par
{\tt \#include \char`\"{}colaerr.h\char`\"{}}\par


Dependencia gr\'{a}fica adjunta para ast.h:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=268pt]{ast_8h__incl}
\end{center}
\end{figure}


Este gr\'{a}fico muestra que archivos directa o indirectamente incluyen a este archivo:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{ast_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Clases}
\begin{CompactItemize}
\item 
struct {\bf variable}
\begin{CompactList}\small\item\em Clase de almacenamiento de variables en el AST. \item\end{CompactList}\item 
struct {\bf constante}
\begin{CompactList}\small\item\em Clase de almacenamiento de constantes en el AST. \item\end{CompactList}\item 
struct {\bf operacion}
\begin{CompactList}\small\item\em Clase de almacenamiento de operaciones en el AST. \item\end{CompactList}\item 
struct {\bf enunciado\-If}
\begin{CompactList}\small\item\em Clase de almacenamiento de enunciados If en el AST. \item\end{CompactList}\item 
struct {\bf enunciado\-While}
\begin{CompactList}\small\item\em Clase de almacenamiento de enunciados while en el AST. \item\end{CompactList}\item 
struct {\bf enunciado\-For}
\begin{CompactList}\small\item\em Clase de almacenamiento de enunciados for en el AST. \item\end{CompactList}\item 
struct {\bf expr}
\begin{CompactList}\small\item\em Clase de almacenamiento de raiz de un arbol de expresiones en el AST. \item\end{CompactList}\item 
struct {\bf asignacion}
\begin{CompactList}\small\item\em Clase de almacenamiento de una asignacion en el AST. \item\end{CompactList}\item 
struct {\bf print\-Call}
\begin{CompactList}\small\item\em Clase de almacenamiento de una llamada a Print o a vartablasimbolos en el AST. \item\end{CompactList}\item 
struct {\bf sentencia}
\begin{CompactList}\small\item\em Clase de almacenamiento de raiz de un arbol de sentencias en el AST, siendo a su vez una lista. \item\end{CompactList}\item 
struct {\bf token}
\begin{CompactList}\small\item\em Clase de almacenamiento de raiz de una lista enlazada de Tokens a imprimir con el comando Print en el AST. \item\end{CompactList}\item 
struct {\bf declaracion}
\begin{CompactList}\small\item\em Clase de almacenamiento de raiz de una declaracion en el AST. \item\end{CompactList}\item 
struct {\bf nodo\-Hijo}
\begin{CompactList}\small\item\em Nodo a usar para pasar entre producciones de la sintaxis, y paso de expresiones al recorrer un arbol de expresiones. \item\end{CompactList}\item 
struct {\bf raiz}
\begin{CompactList}\small\item\em punto de entrada del AST \item\end{CompactList}\item 
struct {\bf ast}
\begin{CompactList}\small\item\em Estructura del arbol abstracto de sintaxis (AST), basico para poder evaluar construcciones iterativas del lenguaje. \item\end{CompactList}\end{CompactItemize}
\subsection*{Definiciones}
\begin{CompactItemize}
\item 
\#define {\bf yyout}~embedout
\begin{CompactList}\small\item\em Aliases de yacc en QT, cambiar a nombre de parser a utilizar. \item\end{CompactList}\end{CompactItemize}
\subsection*{Tipos definidos}
\begin{CompactItemize}
\item 
typedef {\bf sentencia} {\bf sentencia}
\item 
typedef {\bf variable} {\bf variable}
\item 
typedef {\bf constante} {\bf constante}
\item 
typedef {\bf operacion} {\bf operacion}
\item 
typedef {\bf enunciado\-If} {\bf enunciado\-If}
\item 
typedef {\bf enunciado\-While} {\bf enunciado\-While}
\item 
typedef {\bf enunciado\-For} {\bf enunciado\-For}
\item 
typedef {\bf expr} {\bf expr}
\item 
typedef {\bf asignacion} {\bf asignacion}
\item 
typedef {\bf print\-Call} {\bf print\-Call}
\item 
typedef {\bf token} {\bf token}
\item 
typedef {\bf declaracion} {\bf declaracion}
\item 
typedef {\bf enunciado} {\bf enunciado}
\item 
typedef {\bf nodo\-Hijo} {\bf nodo}
\item 
typedef {\bf raiz} {\bf raiz}
\item 
typedef {\bf ast} {\bf ast}
\end{CompactItemize}
\subsection*{Funciones}
\begin{CompactItemize}
\item 
{\bf nodo} $\ast$ {\bf insertar\-Constante} (int, int)
\begin{CompactList}\small\item\em Agrega una constante al arbol de expresiones. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Variable} (char $\ast$)
\begin{CompactList}\small\item\em Agrega una variable al arbol de expresiones. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Cadena} (char $\ast$)
\begin{CompactList}\small\item\em Agrega una cadena al arbol de expresiones. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Operacion} (int, {\bf nodo} $\ast$, {\bf nodo} $\ast$)
\begin{CompactList}\small\item\em Inserta una operacion al arbol de expresiones. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Expresion} ({\bf nodo} $\ast$)
\begin{CompactList}\small\item\em Agrega un nuevo arbol de expresiones al arbol principal. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Asignacion} (char $\ast$, {\bf nodo} $\ast$)
\begin{CompactList}\small\item\em Agrega una asignacion al arbol principal. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Sentencia} (int, {\bf nodo} $\ast$, int)
\begin{CompactList}\small\item\em agrega una sentencia al arbol principal \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Declaracion} (char $\ast$, int)
\begin{CompactList}\small\item\em agrega una nuva declaracion al arbol principal \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Enunciado\-If} ({\bf nodo} $\ast$, {\bf nodo} $\ast$, {\bf nodo} $\ast$)
\begin{CompactList}\small\item\em Agrega un nuevo enunciado if al arbol de sentencias. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Ciclo\-While} ({\bf nodo} $\ast$, {\bf nodo} $\ast$)
\begin{CompactList}\small\item\em Agrega un nuevo ciclo while ar arbol de sentecias. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Ciclo\-For} (char $\ast$, int, int, {\bf nodo} $\ast$)
\begin{CompactList}\small\item\em Agrega un nuevo ciclo for al arbol de sentencias. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Token} (int, void $\ast$)
\begin{CompactList}\small\item\em Agrega un nuevo token al arbol de sentencias. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Llamada} ({\bf nodo} $\ast$)
\begin{CompactList}\small\item\em Agrega un nueva llamada de impresion a yyout al arbol de sentencias. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf insertar\-Llamada\-Sym\-Tab} (int)
\begin{CompactList}\small\item\em Agrega un nueva llamada de impresion de tabla de simbolos al arbol de sentencias. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf concatenar\-Tokens} ({\bf nodo} $\ast$, {\bf nodo} $\ast$)
\begin{CompactList}\small\item\em Concatena tokens para parametros de llamadas. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf concatenar\-Sentencia} ({\bf nodo} $\ast$, {\bf nodo} $\ast$)
\begin{CompactList}\small\item\em Concatena sentencias para caminar por estas. \item\end{CompactList}\item 
void {\bf crear\-Raiz} ({\bf nodo} $\ast$, {\bf ast} $\ast$)
\begin{CompactList}\small\item\em Genera el nodo raiz para el arbol dado en el segundo parametro como punto de inicio del arbol y punto de meta del recorrido sintactico. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf ref\-Nodo\-Hijo} (int tipo, void $\ast$dato)
\begin{CompactList}\small\item\em Crea un nodo que refiere al nodo recien creado para sea utilizado por el nodo anterior a este. \item\end{CompactList}\item 
int {\bf recorrer\-Arbol} ({\bf ast} $\ast$tree, char $\ast$filename)
\begin{CompactList}\small\item\em Recorre el arbol y escribe resultado en archivo salida. \item\end{CompactList}\item 
int {\bf recorrer\-Sentencia} ({\bf sentencia} $\ast$s)
\begin{CompactList}\small\item\em Recorre sentencias recursivamente y devuelve resultado acarreado. \item\end{CompactList}\item 
int {\bf evaluar\-Sentencia} ({\bf sentencia} $\ast$s)
\begin{CompactList}\small\item\em Evalua sentencia y selecciona tipo de sentencia a evaluar. \item\end{CompactList}\item 
int {\bf evaluar\-Declaracion} ({\bf declaracion} $\ast$d)
\begin{CompactList}\small\item\em Evalua declaracion. \item\end{CompactList}\item 
int {\bf evaluar\-Asignacion} ({\bf asignacion} $\ast$a)
\begin{CompactList}\small\item\em Evalua asignacion. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-Expresion} ({\bf expr} $\ast$e)
\begin{CompactList}\small\item\em Evalua expresion y selecciona tipo de expresion a evaluar. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-Operacion} ({\bf operacion} $\ast$o)
\begin{CompactList}\small\item\em Selecciona operacion binaria a evaluar. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-Or} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion logica OR. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-And} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion logica AND. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-GT} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion comparativa Mayor Que. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-GET} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion comparativa Mayor o igual Que. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-LT} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion comparativa Menor Que. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-LET} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion comparativa Menor o Igual Que. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-EQ} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion comparativa Igual. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-NEQ} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion comparativa Desigual. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-Suma} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion aritmetica Suma, y la concatenacion de cadenas. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-Resta} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion aritmetica Resta. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-Mult} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion aritmetica Multiplicacion. \item\end{CompactList}\item 
{\bf nodo} $\ast$ {\bf evaluar\-Div} ({\bf nodo} $\ast$n1, {\bf nodo} $\ast$n2)
\begin{CompactList}\small\item\em Evalua operacion aritmetica Division. \item\end{CompactList}\item 
int {\bf evaluar\-If} ({\bf enunciado\-If} $\ast$eif)
\begin{CompactList}\small\item\em Evalua bifurcacion If. \item\end{CompactList}\item 
int {\bf evaluar\-While} ({\bf enunciado\-While} $\ast$ew)
\begin{CompactList}\small\item\em Evalua bucle While. \item\end{CompactList}\item 
int {\bf evaluar\-For} ({\bf enunciado\-For} $\ast$ef)
\begin{CompactList}\small\item\em Evalua bucle For. \item\end{CompactList}\item 
int {\bf evaluar\-Print\-Call} ({\bf print\-Call} $\ast$pc)
\begin{CompactList}\small\item\em Evalua llamada a imprimir en archivo. \item\end{CompactList}\item 
int {\bf imprimir\-Tokens} ({\bf token} $\ast$t)
\begin{CompactList}\small\item\em Evalua recursivamente lista de tokens a imprimir. \item\end{CompactList}\item 
void {\bf error} (char $\ast$err, int tipo, void $\ast$dato)
\begin{CompactList}\small\item\em Escribe error semantico hacia cola de errores semanticos. \item\end{CompactList}\item 
void {\bf borrar\-Arbol} ({\bf ast} $\ast$tree)
\begin{CompactList}\small\item\em Funciones de eliminacion logica. \item\end{CompactList}\item 
void {\bf borrar\-Sentencias} ({\bf sentencia} $\ast$s)
\begin{CompactList}\small\item\em Borra nodo sentencia. \item\end{CompactList}\item 
void {\bf borrar\-Declaracion} ({\bf declaracion} $\ast$d)
\begin{CompactList}\small\item\em Borra nodo declaracion. \item\end{CompactList}\item 
void {\bf borrar\-Asignacion} ({\bf asignacion} $\ast$a)
\begin{CompactList}\small\item\em Borrar Asignacion. \item\end{CompactList}\item 
void {\bf borrar\-Expresion} ({\bf expr} $\ast$e)
\begin{CompactList}\small\item\em Elimina de memoria arbol de expresiones. \item\end{CompactList}\item 
void {\bf borrar\-Operacion} ({\bf operacion} $\ast$o)
\begin{CompactList}\small\item\em borra nodo operacion de mem \item\end{CompactList}\item 
void {\bf borrar\-If} ({\bf enunciado\-If} $\ast$eif)
\begin{CompactList}\small\item\em borra nodo if \item\end{CompactList}\item 
void {\bf borrar\-While} ({\bf enunciado\-While} $\ast$ew)
\begin{CompactList}\small\item\em borra nodo While \item\end{CompactList}\item 
void {\bf borrar\-For} ({\bf enunciado\-For} $\ast$ef)
\begin{CompactList}\small\item\em borra nodo for \item\end{CompactList}\item 
void {\bf borrar\-Print\-Call} ({\bf print\-Call} $\ast$pc)
\begin{CompactList}\small\item\em borra nodo de llamada a imprimir en archivo \item\end{CompactList}\item 
void {\bf borrar\-Tokens} ({\bf token} $\ast$t)
\begin{CompactList}\small\item\em borra recursivamente listado de tokens \item\end{CompactList}\end{CompactItemize}


\subsection{Descripci\'{o}n detallada}
Definiciones y estructura del arbol de sintaxis abstracta. 



Definici\'{o}n en el archivo {\bf ast.h}.

\subsection{Documentaci\'{o}n de las definiciones}
\index{ast.h@{ast.h}!yyout@{yyout}}
\index{yyout@{yyout}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}\#define {\bf yyout}~embedout}\label{ast_8h_a0}


Aliases de yacc en QT, cambiar a nombre de parser a utilizar. 



Definici\'{o}n en la l\'{\i}nea 11 del archivo ast.h.

Referenciado por imprimir\-Tokens().

\subsection{Documentaci\'{o}n de los tipos definidos}
\index{ast.h@{ast.h}!asignacion@{asignacion}}
\index{asignacion@{asignacion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf asignacion} {\bf asignacion}}\label{ast_8h_a9}




Definici\'{o}n en la l\'{\i}nea 31 del archivo ast.h.\index{ast.h@{ast.h}!ast@{ast}}
\index{ast@{ast}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf ast} {\bf ast}}\label{ast_8h_a16}




Definici\'{o}n en la l\'{\i}nea 38 del archivo ast.h.\index{ast.h@{ast.h}!constante@{constante}}
\index{constante@{constante}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf constante} {\bf constante}}\label{ast_8h_a3}




Definici\'{o}n en la l\'{\i}nea 25 del archivo ast.h.\index{ast.h@{ast.h}!declaracion@{declaracion}}
\index{declaracion@{declaracion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf declaracion} {\bf declaracion}}\label{ast_8h_a12}




Definici\'{o}n en la l\'{\i}nea 34 del archivo ast.h.\index{ast.h@{ast.h}!enunciado@{enunciado}}
\index{enunciado@{enunciado}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf enunciado} {\bf enunciado}}\label{ast_8h_a13}




Definici\'{o}n en la l\'{\i}nea 35 del archivo ast.h.\index{ast.h@{ast.h}!enunciadoFor@{enunciadoFor}}
\index{enunciadoFor@{enunciadoFor}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf enunciado\-For} {\bf enunciado\-For}}\label{ast_8h_a7}




Definici\'{o}n en la l\'{\i}nea 29 del archivo ast.h.\index{ast.h@{ast.h}!enunciadoIf@{enunciadoIf}}
\index{enunciadoIf@{enunciadoIf}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf enunciado\-If} {\bf enunciado\-If}}\label{ast_8h_a5}




Definici\'{o}n en la l\'{\i}nea 27 del archivo ast.h.\index{ast.h@{ast.h}!enunciadoWhile@{enunciadoWhile}}
\index{enunciadoWhile@{enunciadoWhile}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf enunciado\-While} {\bf enunciado\-While}}\label{ast_8h_a6}




Definici\'{o}n en la l\'{\i}nea 28 del archivo ast.h.\index{ast.h@{ast.h}!expr@{expr}}
\index{expr@{expr}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf expr} {\bf expr}}\label{ast_8h_a8}




Definici\'{o}n en la l\'{\i}nea 30 del archivo ast.h.\index{ast.h@{ast.h}!nodo@{nodo}}
\index{nodo@{nodo}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf nodo\-Hijo} {\bf nodo}}\label{ast_8h_a14}




Definici\'{o}n en la l\'{\i}nea 36 del archivo ast.h.\index{ast.h@{ast.h}!operacion@{operacion}}
\index{operacion@{operacion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf operacion} {\bf operacion}}\label{ast_8h_a4}




Definici\'{o}n en la l\'{\i}nea 26 del archivo ast.h.\index{ast.h@{ast.h}!printCall@{printCall}}
\index{printCall@{printCall}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf print\-Call} {\bf print\-Call}}\label{ast_8h_a10}




Definici\'{o}n en la l\'{\i}nea 32 del archivo ast.h.\index{ast.h@{ast.h}!raiz@{raiz}}
\index{raiz@{raiz}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf raiz} {\bf raiz}}\label{ast_8h_a15}




Definici\'{o}n en la l\'{\i}nea 37 del archivo ast.h.\index{ast.h@{ast.h}!sentencia@{sentencia}}
\index{sentencia@{sentencia}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf sentencia} {\bf sentencia}}\label{ast_8h_a1}




Definici\'{o}n en la l\'{\i}nea 23 del archivo ast.h.\index{ast.h@{ast.h}!token@{token}}
\index{token@{token}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf token} {\bf token}}\label{ast_8h_a11}




Definici\'{o}n en la l\'{\i}nea 33 del archivo ast.h.\index{ast.h@{ast.h}!variable@{variable}}
\index{variable@{variable}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf variable} {\bf variable}}\label{ast_8h_a2}




Definici\'{o}n en la l\'{\i}nea 24 del archivo ast.h.

\subsection{Documentaci\'{o}n de las funciones}
\index{ast.h@{ast.h}!borrarArbol@{borrarArbol}}
\index{borrarArbol@{borrarArbol}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-Arbol ({\bf ast} $\ast$ {\em tree})}\label{ast_8h_a60}


Funciones de eliminacion logica. 



Definici\'{o}n en la l\'{\i}nea 897 del archivo ast.c.

Hace referencia a ast::actual, borrar\-Sentencias(), raiz::hijo, ast::root, y ast::tipo\-Actual.\index{ast.h@{ast.h}!borrarAsignacion@{borrarAsignacion}}
\index{borrarAsignacion@{borrarAsignacion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-Asignacion ({\bf asignacion} $\ast$ {\em a})}\label{ast_8h_a63}


Borrar Asignacion. 



Definici\'{o}n en la l\'{\i}nea 952 del archivo ast.c.

Hace referencia a borrar\-Expresion(), asignacion::hijo, y asignacion::variable.

Referenciado por borrar\-Sentencias().\index{ast.h@{ast.h}!borrarDeclaracion@{borrarDeclaracion}}
\index{borrarDeclaracion@{borrarDeclaracion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-Declaracion ({\bf declaracion} $\ast$ {\em d})}\label{ast_8h_a62}


Borra nodo declaracion. 



Definici\'{o}n en la l\'{\i}nea 943 del archivo ast.c.

Hace referencia a declaracion::identificador.

Referenciado por borrar\-Sentencias().\index{ast.h@{ast.h}!borrarExpresion@{borrarExpresion}}
\index{borrarExpresion@{borrarExpresion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-Expresion ({\bf expr} $\ast$ {\em e})}\label{ast_8h_a64}


Elimina de memoria arbol de expresiones. 



Definici\'{o}n en la l\'{\i}nea 962 del archivo ast.c.

Hace referencia a borrar\-Operacion(), expr::hijo, T\_\-CONSTANTE, T\_\-LITERAL, T\_\-OPERACION, T\_\-VARIABLE, y expr::tipo.

Referenciado por borrar\-Asignacion(), borrar\-If(), borrar\-Operacion(), y borrar\-While().\index{ast.h@{ast.h}!borrarFor@{borrarFor}}
\index{borrarFor@{borrarFor}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-For ({\bf enunciado\-For} $\ast$ {\em ef})}\label{ast_8h_a68}


borra nodo for 



Definici\'{o}n en la l\'{\i}nea 1017 del archivo ast.c.

Hace referencia a borrar\-Sentencias(), enunciado\-For::cuerpo, y enunciado\-For::indice.

Referenciado por borrar\-Sentencias().\index{ast.h@{ast.h}!borrarIf@{borrarIf}}
\index{borrarIf@{borrarIf}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-If ({\bf enunciado\-If} $\ast$ {\em eif})}\label{ast_8h_a66}


borra nodo if 



Definici\'{o}n en la l\'{\i}nea 995 del archivo ast.c.

Hace referencia a borrar\-Expresion(), borrar\-Sentencias(), enunciado\-If::else\_\-stmt, enunciado\-If::test, y enunciado\-If::then\_\-stmt.

Referenciado por borrar\-Sentencias().\index{ast.h@{ast.h}!borrarOperacion@{borrarOperacion}}
\index{borrarOperacion@{borrarOperacion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-Operacion ({\bf operacion} $\ast$ {\em o})}\label{ast_8h_a65}


borra nodo operacion de mem 



Definici\'{o}n en la l\'{\i}nea 985 del archivo ast.c.

Hace referencia a borrar\-Expresion(), operacion::loper, y operacion::roper.

Referenciado por borrar\-Expresion().\index{ast.h@{ast.h}!borrarPrintCall@{borrarPrintCall}}
\index{borrarPrintCall@{borrarPrintCall}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-Print\-Call ({\bf print\-Call} $\ast$ {\em pc})}\label{ast_8h_a69}


borra nodo de llamada a imprimir en archivo 



Definici\'{o}n en la l\'{\i}nea 1026 del archivo ast.c.

Hace referencia a borrar\-Tokens(), y print\-Call::hijos.

Referenciado por borrar\-Sentencias().\index{ast.h@{ast.h}!borrarSentencias@{borrarSentencias}}
\index{borrarSentencias@{borrarSentencias}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-Sentencias ({\bf sentencia} $\ast$ {\em s})}\label{ast_8h_a61}


Borra nodo sentencia. 



Definici\'{o}n en la l\'{\i}nea 914 del archivo ast.c.

Hace referencia a borrar\-Asignacion(), borrar\-Declaracion(), borrar\-For(), borrar\-If(), borrar\-Print\-Call(), borrar\-Sentencias(), borrar\-While(), sentencia::hijo, sentencia::siguiente, T\_\-ASIGNACION, T\_\-CALL, T\_\-DECLARACION, T\_\-FOR, T\_\-IF, T\_\-WHILE, y sentencia::tipo.

Referenciado por borrar\-Arbol(), borrar\-For(), borrar\-If(), borrar\-Sentencias(), y borrar\-While().\index{ast.h@{ast.h}!borrarTokens@{borrarTokens}}
\index{borrarTokens@{borrarTokens}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-Tokens ({\bf token} $\ast$ {\em t})}\label{ast_8h_a70}


borra recursivamente listado de tokens 



Definici\'{o}n en la l\'{\i}nea 1036 del archivo ast.c.

Hace referencia a borrar\-Tokens(), token::hijo, token::siguiente, T\_\-CADENA, T\_\-STRING, y token::tipo.

Referenciado por borrar\-Print\-Call(), y borrar\-Tokens().\index{ast.h@{ast.h}!borrarWhile@{borrarWhile}}
\index{borrarWhile@{borrarWhile}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void borrar\-While ({\bf enunciado\-While} $\ast$ {\em ew})}\label{ast_8h_a67}


borra nodo While 



Definici\'{o}n en la l\'{\i}nea 1008 del archivo ast.c.

Hace referencia a borrar\-Expresion(), borrar\-Sentencias(), enunciado\-While::cuerpo, y enunciado\-While::test.

Referenciado por borrar\-Sentencias().\index{ast.h@{ast.h}!concatenarSentencia@{concatenarSentencia}}
\index{concatenarSentencia@{concatenarSentencia}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ concatenar\-Sentencia ({\bf nodo} $\ast$, {\bf nodo} $\ast$)}\label{ast_8h_a32}


Concatena sentencias para caminar por estas. 



Definici\'{o}n en la l\'{\i}nea 140 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, y sentencia::siguiente.\index{ast.h@{ast.h}!concatenarTokens@{concatenarTokens}}
\index{concatenarTokens@{concatenarTokens}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ concatenar\-Tokens ({\bf nodo} $\ast$, {\bf nodo} $\ast$)}\label{ast_8h_a31}


Concatena tokens para parametros de llamadas. 



Definici\'{o}n en la l\'{\i}nea 231 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, y token::siguiente.\index{ast.h@{ast.h}!crearRaiz@{crearRaiz}}
\index{crearRaiz@{crearRaiz}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void crear\-Raiz ({\bf nodo} $\ast$, {\bf ast} $\ast$)}\label{ast_8h_a33}


Genera el nodo raiz para el arbol dado en el segundo parametro como punto de inicio del arbol y punto de meta del recorrido sintactico. 



Definici\'{o}n en la l\'{\i}nea 263 del archivo ast.c.

Hace referencia a ast::actual, nodo\-Hijo::dato, raiz::hijo, ast::root, T\_\-SENTENCIA, y ast::tipo\-Actual.\index{ast.h@{ast.h}!error@{error}}
\index{error@{error}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void error (char $\ast$ {\em err}, int {\em tipo}, void $\ast$ {\em dato})}\label{ast_8h_a59}


Escribe error semantico hacia cola de errores semanticos. 



Definici\'{o}n en la l\'{\i}nea 280 del archivo ast.c.

Hace referencia a error\-Semantico(), sentencia::num\-Linea, y T\_\-SENTENCIA.

Referenciado por evaluar\-And(), evaluar\-Asignacion(), evaluar\-Declaracion(), evaluar\-Div(), evaluar\-Expresion(), evaluar\-For(), evaluar\-GET(), evaluar\-GT(), evaluar\-If(), evaluar\-LET(), evaluar\-LT(), evaluar\-Mult(), evaluar\-Or(), evaluar\-Print\-Call(), evaluar\-Resta(), evaluar\-Suma(), evaluar\-While(), imprimir\-Tokens(), y recorrer\-Sentencia().\index{ast.h@{ast.h}!evaluarAnd@{evaluarAnd}}
\index{evaluarAnd@{evaluarAnd}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-And ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a43}


Evalua operacion logica AND. 



Definici\'{o}n en la l\'{\i}nea 491 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-OPERACION, T\_\-TRUE, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarAsignacion@{evaluarAsignacion}}
\index{evaluarAsignacion@{evaluarAsignacion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int evaluar\-Asignacion ({\bf asignacion} $\ast$ {\em a})}\label{ast_8h_a39}


Evalua asignacion. 



Definici\'{o}n en la l\'{\i}nea 359 del archivo ast.c.

Hace referencia a buscar\-Simbolo(), nodo\-Hijo::dato, error(), evaluar\-Expresion(), asignacion::hijo, T\_\-ASIGNACION, T\_\-BOOLEAN, T\_\-INTEGER, T\_\-NUMERO, symbol::tipo, nodo\-Hijo::tipo, symbol::valor, y asignacion::variable.

Referenciado por evaluar\-Sentencia().\index{ast.h@{ast.h}!evaluarDeclaracion@{evaluarDeclaracion}}
\index{evaluarDeclaracion@{evaluarDeclaracion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int evaluar\-Declaracion ({\bf declaracion} $\ast$ {\em d})}\label{ast_8h_a38}


Evalua declaracion. 



Definici\'{o}n en la l\'{\i}nea 350 del archivo ast.c.

Hace referencia a buscar\-Simbolo(), error(), declaracion::identificador, insertar\-Simbolo(), T\_\-DECLARACION, y declaracion::tipo.

Referenciado por evaluar\-Sentencia().\index{ast.h@{ast.h}!evaluarDiv@{evaluarDiv}}
\index{evaluarDiv@{evaluarDiv}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-Div ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a53}


Evalua operacion aritmetica Division. 



Definici\'{o}n en la l\'{\i}nea 671 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-INTEGER, T\_\-OPERACION, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarEQ@{evaluarEQ}}
\index{evaluarEQ@{evaluarEQ}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-EQ ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a48}


Evalua operacion comparativa Igual. 



Definici\'{o}n en la l\'{\i}nea 535 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, ref\-Nodo\-Hijo(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-INTEGER, T\_\-STRING, T\_\-TRUE, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarExpresion@{evaluarExpresion}}
\index{evaluarExpresion@{evaluarExpresion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-Expresion ({\bf expr} $\ast$ {\em e})}\label{ast_8h_a40}


Evalua expresion y selecciona tipo de expresion a evaluar. 



Definici\'{o}n en la l\'{\i}nea 391 del archivo ast.c.

Hace referencia a buscar\-Simbolo(), nodo\-Hijo::dato, error(), evaluar\-Operacion(), expr::hijo, T\_\-BOOLEAN, T\_\-CONSTANTE, T\_\-EXPR, T\_\-INTEGER, T\_\-LITERAL, T\_\-NUMERO, T\_\-OPERACION, T\_\-STRING, T\_\-VARIABLE, symbol::tipo, nodo\-Hijo::tipo, expr::tipo, y symbol::valor.

Referenciado por evaluar\-Asignacion(), evaluar\-If(), evaluar\-Operacion(), y evaluar\-While().\index{ast.h@{ast.h}!evaluarFor@{evaluarFor}}
\index{evaluarFor@{evaluarFor}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int evaluar\-For ({\bf enunciado\-For} $\ast$ {\em ef})}\label{ast_8h_a56}


Evalua bucle For. 



Definici\'{o}n en la l\'{\i}nea 807 del archivo ast.c.

Hace referencia a enunciado\-For::asignacion, buscar\-Simbolo(), enunciado\-For::cuerpo, error(), enunciado\-For::indice, enunciado\-For::limite, recorrer\-Sentencia(), T\_\-FOR, T\_\-INTEGER, symbol::tipo, y symbol::valor.

Referenciado por evaluar\-Sentencia().\index{ast.h@{ast.h}!evaluarGET@{evaluarGET}}
\index{evaluarGET@{evaluarGET}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-GET ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a45}


Evalua operacion comparativa Mayor o igual Que. 



Definici\'{o}n en la l\'{\i}nea 611 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-INTEGER, T\_\-OPERACION, T\_\-TRUE, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarGT@{evaluarGT}}
\index{evaluarGT@{evaluarGT}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-GT ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a44}


Evalua operacion comparativa Mayor Que. 



Definici\'{o}n en la l\'{\i}nea 591 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-INTEGER, T\_\-OPERACION, T\_\-TRUE, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarIf@{evaluarIf}}
\index{evaluarIf@{evaluarIf}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int evaluar\-If ({\bf enunciado\-If} $\ast$ {\em eif})}\label{ast_8h_a54}


Evalua bifurcacion If. 



Definici\'{o}n en la l\'{\i}nea 746 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, enunciado\-If::else\_\-stmt, error(), evaluar\-Expresion(), recorrer\-Sentencia(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-IF, T\_\-TRUE, enunciado\-If::test, enunciado\-If::then\_\-stmt, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Sentencia().\index{ast.h@{ast.h}!evaluarLET@{evaluarLET}}
\index{evaluarLET@{evaluarLET}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-LET ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a47}


Evalua operacion comparativa Menor o Igual Que. 



Definici\'{o}n en la l\'{\i}nea 651 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-INTEGER, T\_\-OPERACION, T\_\-TRUE, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarLT@{evaluarLT}}
\index{evaluarLT@{evaluarLT}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-LT ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a46}


Evalua operacion comparativa Menor Que. 



Definici\'{o}n en la l\'{\i}nea 631 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-INTEGER, T\_\-OPERACION, T\_\-TRUE, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarMult@{evaluarMult}}
\index{evaluarMult@{evaluarMult}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-Mult ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a52}


Evalua operacion aritmetica Multiplicacion. 



Definici\'{o}n en la l\'{\i}nea 693 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-INTEGER, T\_\-OPERACION, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarNEQ@{evaluarNEQ}}
\index{evaluarNEQ@{evaluarNEQ}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-NEQ ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a49}


Evalua operacion comparativa Desigual. 



Definici\'{o}n en la l\'{\i}nea 563 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, ref\-Nodo\-Hijo(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-INTEGER, T\_\-STRING, T\_\-TRUE, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarOperacion@{evaluarOperacion}}
\index{evaluarOperacion@{evaluarOperacion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-Operacion ({\bf operacion} $\ast$ {\em o})}\label{ast_8h_a41}


Selecciona operacion binaria a evaluar. 



Definici\'{o}n en la l\'{\i}nea 444 del archivo ast.c.

Hace referencia a evaluar\-And(), evaluar\-Div(), evaluar\-EQ(), evaluar\-Expresion(), evaluar\-GET(), evaluar\-GT(), evaluar\-LET(), evaluar\-LT(), evaluar\-Mult(), evaluar\-NEQ(), evaluar\-Or(), evaluar\-Resta(), evaluar\-Suma(), operacion::loper, OP\_\-AND, OP\_\-DIV, OP\_\-EQ, OP\_\-GET, OP\_\-GT, OP\_\-LET, OP\_\-LT, OP\_\-MULT, OP\_\-NEQ, OP\_\-OR, OP\_\-RESTA, OP\_\-SUMA, operacion::operador, y operacion::roper.

Referenciado por evaluar\-Expresion().\index{ast.h@{ast.h}!evaluarOr@{evaluarOr}}
\index{evaluarOr@{evaluarOr}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-Or ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a42}


Evalua operacion logica OR. 



Definici\'{o}n en la l\'{\i}nea 513 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-OPERACION, T\_\-TRUE, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarPrintCall@{evaluarPrintCall}}
\index{evaluarPrintCall@{evaluarPrintCall}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int evaluar\-Print\-Call ({\bf print\-Call} $\ast$ {\em pc})}\label{ast_8h_a57}


Evalua llamada a imprimir en archivo. 



Definici\'{o}n en la l\'{\i}nea 836 del archivo ast.c.

Hace referencia a error(), print\-Call::hijos, imprimir\-Tokens(), T\_\-CALL, T\_\-PRINTCALL, y print\-Call::tipo.

Referenciado por evaluar\-Sentencia().\index{ast.h@{ast.h}!evaluarResta@{evaluarResta}}
\index{evaluarResta@{evaluarResta}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-Resta ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a51}


Evalua operacion aritmetica Resta. 



Definici\'{o}n en la l\'{\i}nea 707 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-INTEGER, T\_\-OPERACION, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarSentencia@{evaluarSentencia}}
\index{evaluarSentencia@{evaluarSentencia}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int evaluar\-Sentencia ({\bf sentencia} $\ast$ {\em s})}\label{ast_8h_a37}


Evalua sentencia y selecciona tipo de sentencia a evaluar. 



Definici\'{o}n en la l\'{\i}nea 317 del archivo ast.c.

Hace referencia a evaluar\-Asignacion(), evaluar\-Declaracion(), evaluar\-For(), evaluar\-If(), evaluar\-Print\-Call(), evaluar\-While(), sentencia::hijo, T\_\-ASIGNACION, T\_\-CALL, T\_\-DECLARACION, T\_\-ERROR, T\_\-FOR, T\_\-IF, T\_\-WHILE, y sentencia::tipo.

Referenciado por recorrer\-Sentencia().\index{ast.h@{ast.h}!evaluarSuma@{evaluarSuma}}
\index{evaluarSuma@{evaluarSuma}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ evaluar\-Suma ({\bf nodo} $\ast$ {\em n1}, {\bf nodo} $\ast$ {\em n2})}\label{ast_8h_a50}


Evalua operacion aritmetica Suma, y la concatenacion de cadenas. 



Definici\'{o}n en la l\'{\i}nea 721 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, error(), ref\-Nodo\-Hijo(), T\_\-INTEGER, T\_\-OPERACION, T\_\-STRING, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Operacion().\index{ast.h@{ast.h}!evaluarWhile@{evaluarWhile}}
\index{evaluarWhile@{evaluarWhile}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int evaluar\-While ({\bf enunciado\-While} $\ast$ {\em ew})}\label{ast_8h_a55}


Evalua bucle While. 



Definici\'{o}n en la l\'{\i}nea 778 del archivo ast.c.

Hace referencia a enunciado\-While::cuerpo, nodo\-Hijo::dato, error(), evaluar\-Expresion(), recorrer\-Sentencia(), T\_\-BOOLEAN, T\_\-FALSE, T\_\-TRUE, T\_\-WHILE, enunciado\-While::test, y nodo\-Hijo::tipo.

Referenciado por evaluar\-Sentencia().\index{ast.h@{ast.h}!imprimirTokens@{imprimirTokens}}
\index{imprimirTokens@{imprimirTokens}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int imprimir\-Tokens ({\bf token} $\ast$ {\em t})}\label{ast_8h_a58}


Evalua recursivamente lista de tokens a imprimir. 



Definici\'{o}n en la l\'{\i}nea 852 del archivo ast.c.

Hace referencia a buscar\-Simbolo(), error(), token::hijo, imprimir\-Tokens(), token::siguiente, T\_\-BOOLEAN, T\_\-CADENA, T\_\-IDENTIFICADOR, T\_\-INTEGER, T\_\-NUMERO, T\_\-STRING, T\_\-TOKEN, symbol::tipo, token::tipo, symbol::valor, y yyout.

Referenciado por evaluar\-Print\-Call(), y imprimir\-Tokens().\index{ast.h@{ast.h}!insertarAsignacion@{insertarAsignacion}}
\index{insertarAsignacion@{insertarAsignacion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Asignacion (char $\ast$, {\bf nodo} $\ast$)}\label{ast_8h_a22}


Agrega una asignacion al arbol principal. 



Definici\'{o}n en la l\'{\i}nea 88 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, asignacion::hijo, ref\-Nodo\-Hijo(), T\_\-ASIGNACION, y asignacion::variable.\index{ast.h@{ast.h}!insertarCadena@{insertarCadena}}
\index{insertarCadena@{insertarCadena}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Cadena (char $\ast$)}\label{ast_8h_a19}


Agrega una cadena al arbol de expresiones. 



Definici\'{o}n en la l\'{\i}nea 39 del archivo ast.c.

Hace referencia a expr::hijo, ref\-Nodo\-Hijo(), T\_\-EXPR, T\_\-LITERAL, y expr::tipo.\index{ast.h@{ast.h}!insertarCicloFor@{insertarCicloFor}}
\index{insertarCicloFor@{insertarCicloFor}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Ciclo\-For (char $\ast$, int, int, {\bf nodo} $\ast$)}\label{ast_8h_a27}


Agrega un nuevo ciclo for al arbol de sentencias. 



Definici\'{o}n en la l\'{\i}nea 194 del archivo ast.c.

Hace referencia a enunciado\-For::asignacion, enunciado\-For::cuerpo, nodo\-Hijo::dato, enunciado\-For::indice, enunciado\-For::limite, ref\-Nodo\-Hijo(), y T\_\-FOR.\index{ast.h@{ast.h}!insertarCicloWhile@{insertarCicloWhile}}
\index{insertarCicloWhile@{insertarCicloWhile}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Ciclo\-While ({\bf nodo} $\ast$, {\bf nodo} $\ast$)}\label{ast_8h_a26}


Agrega un nuevo ciclo while ar arbol de sentecias. 



Definici\'{o}n en la l\'{\i}nea 183 del archivo ast.c.

Hace referencia a enunciado\-While::cuerpo, nodo\-Hijo::dato, ref\-Nodo\-Hijo(), T\_\-WHILE, y enunciado\-While::test.\index{ast.h@{ast.h}!insertarConstante@{insertarConstante}}
\index{insertarConstante@{insertarConstante}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Constante (int, int)}\label{ast_8h_a17}


Agrega una constante al arbol de expresiones. 



Definici\'{o}n en la l\'{\i}nea 24 del archivo ast.c.

Hace referencia a constante::dato, ref\-Nodo\-Hijo(), T\_\-CONSTANTE, y constante::tipo.\index{ast.h@{ast.h}!insertarDeclaracion@{insertarDeclaracion}}
\index{insertarDeclaracion@{insertarDeclaracion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Declaracion (char $\ast$, int)}\label{ast_8h_a24}


agrega una nuva declaracion al arbol principal 



Definici\'{o}n en la l\'{\i}nea 158 del archivo ast.c.

Hace referencia a declaracion::identificador, ref\-Nodo\-Hijo(), T\_\-DECLARACION, y declaracion::tipo.\index{ast.h@{ast.h}!insertarEnunciadoIf@{insertarEnunciadoIf}}
\index{insertarEnunciadoIf@{insertarEnunciadoIf}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Enunciado\-If ({\bf nodo} $\ast$, {\bf nodo} $\ast$, {\bf nodo} $\ast$)}\label{ast_8h_a25}


Agrega un nuevo enunciado if al arbol de sentencias. 



Definici\'{o}n en la l\'{\i}nea 166 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, enunciado\-If::else\_\-stmt, ref\-Nodo\-Hijo(), T\_\-IF, enunciado\-If::test, y enunciado\-If::then\_\-stmt.\index{ast.h@{ast.h}!insertarExpresion@{insertarExpresion}}
\index{insertarExpresion@{insertarExpresion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Expresion ({\bf nodo} $\ast$)}\label{ast_8h_a21}


Agrega un nuevo arbol de expresiones al arbol principal. 



Definici\'{o}n en la l\'{\i}nea 61 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, expr::hijo, ref\-Nodo\-Hijo(), T\_\-CONSTANTE, T\_\-EXPR, T\_\-OPERACION, T\_\-VARIABLE, expr::tipo, y nodo\-Hijo::tipo.

Referenciado por insertar\-Operacion().\index{ast.h@{ast.h}!insertarLlamada@{insertarLlamada}}
\index{insertarLlamada@{insertarLlamada}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Llamada ({\bf nodo} $\ast$)}\label{ast_8h_a29}


Agrega un nueva llamada de impresion a yyout al arbol de sentencias. 



Definici\'{o}n en la l\'{\i}nea 243 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, print\-Call::hijos, ref\-Nodo\-Hijo(), T\_\-CALL, T\_\-PRINTCALL, y print\-Call::tipo.\index{ast.h@{ast.h}!insertarLlamadaSymTab@{insertarLlamadaSymTab}}
\index{insertarLlamadaSymTab@{insertarLlamadaSymTab}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Llamada\-Sym\-Tab (int)}\label{ast_8h_a30}


Agrega un nueva llamada de impresion de tabla de simbolos al arbol de sentencias. 



Definici\'{o}n en la l\'{\i}nea 254 del archivo ast.c.

Hace referencia a print\-Call::hijos, print\-Symtab\-File(), ref\-Nodo\-Hijo(), T\_\-CALL, T\_\-PRINTSYMCALL, y print\-Call::tipo.\index{ast.h@{ast.h}!insertarOperacion@{insertarOperacion}}
\index{insertarOperacion@{insertarOperacion}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Operacion (int, {\bf nodo} $\ast$, {\bf nodo} $\ast$)}\label{ast_8h_a20}


Inserta una operacion al arbol de expresiones. 



Definici\'{o}n en la l\'{\i}nea 49 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, insertar\-Expresion(), operacion::loper, operacion::operador, ref\-Nodo\-Hijo(), operacion::roper, y T\_\-OPERACION.\index{ast.h@{ast.h}!insertarSentencia@{insertarSentencia}}
\index{insertarSentencia@{insertarSentencia}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Sentencia (int, {\bf nodo} $\ast$, int)}\label{ast_8h_a23}


agrega una sentencia al arbol principal 



Definici\'{o}n en la l\'{\i}nea 100 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, sentencia::hijo, sentencia::num\-Linea, ref\-Nodo\-Hijo(), sentencia::siguiente, T\_\-ASIGNACION, T\_\-CALL, T\_\-DECLARACION, T\_\-ERROR, T\_\-FOR, T\_\-IF, T\_\-SENTENCIA, T\_\-WHILE, y sentencia::tipo.\index{ast.h@{ast.h}!insertarToken@{insertarToken}}
\index{insertarToken@{insertarToken}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Token (int, void $\ast$)}\label{ast_8h_a28}


Agrega un nuevo token al arbol de sentencias. 



Definici\'{o}n en la l\'{\i}nea 207 del archivo ast.c.

Hace referencia a token::hijo, ref\-Nodo\-Hijo(), token::siguiente, T\_\-CADENA, T\_\-IDENTIFICADOR, T\_\-INTEGER, T\_\-NUMERO, T\_\-STRING, T\_\-TOKEN, y token::tipo.\index{ast.h@{ast.h}!insertarVariable@{insertarVariable}}
\index{insertarVariable@{insertarVariable}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ insertar\-Variable (char $\ast$)}\label{ast_8h_a18}


Agrega una variable al arbol de expresiones. 



Definici\'{o}n en la l\'{\i}nea 31 del archivo ast.c.

Hace referencia a variable::identificador, ref\-Nodo\-Hijo(), y T\_\-VARIABLE.\index{ast.h@{ast.h}!recorrerArbol@{recorrerArbol}}
\index{recorrerArbol@{recorrerArbol}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int recorrer\-Arbol ({\bf ast} $\ast$ {\em tree}, char $\ast$ {\em filename})}\label{ast_8h_a35}


Recorre el arbol y escribe resultado en archivo salida. 



Definici\'{o}n en la l\'{\i}nea 294 del archivo ast.c.

Hace referencia a raiz::hijo, recorrer\-Sentencia(), y ast::root.\index{ast.h@{ast.h}!recorrerSentencia@{recorrerSentencia}}
\index{recorrerSentencia@{recorrerSentencia}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int recorrer\-Sentencia ({\bf sentencia} $\ast$ {\em s})}\label{ast_8h_a36}


Recorre sentencias recursivamente y devuelve resultado acarreado. 



Definici\'{o}n en la l\'{\i}nea 305 del archivo ast.c.

Hace referencia a error(), evaluar\-Sentencia(), recorrer\-Sentencia(), sentencia::siguiente, y T\_\-SENTENCIA.

Referenciado por evaluar\-For(), evaluar\-If(), evaluar\-While(), recorrer\-Arbol(), y recorrer\-Sentencia().\index{ast.h@{ast.h}!refNodoHijo@{refNodoHijo}}
\index{refNodoHijo@{refNodoHijo}!ast.h@{ast.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf nodo}$\ast$ ref\-Nodo\-Hijo (int {\em tipo}, void $\ast$ {\em dato})}\label{ast_8h_a34}


Crea un nodo que refiere al nodo recien creado para sea utilizado por el nodo anterior a este. 



Definici\'{o}n en la l\'{\i}nea 17 del archivo ast.c.

Hace referencia a nodo\-Hijo::dato, y nodo\-Hijo::tipo.

Referenciado por evaluar\-And(), evaluar\-Div(), evaluar\-EQ(), evaluar\-GET(), evaluar\-GT(), evaluar\-LET(), evaluar\-LT(), evaluar\-Mult(), evaluar\-NEQ(), evaluar\-Or(), evaluar\-Resta(), evaluar\-Suma(), insertar\-Asignacion(), insertar\-Cadena(), insertar\-Ciclo\-For(), insertar\-Ciclo\-While(), insertar\-Constante(), insertar\-Declaracion(), insertar\-Enunciado\-If(), insertar\-Expresion(), insertar\-Llamada(), insertar\-Llamada\-Sym\-Tab(), insertar\-Operacion(), insertar\-Sentencia(), insertar\-Token(), y insertar\-Variable().