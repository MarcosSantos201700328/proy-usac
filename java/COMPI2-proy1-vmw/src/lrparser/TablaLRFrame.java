/*
 * TablaLRFrame.java
 *
 * Created on 11 de marzo de 2007, 03:13 PM
 */

package lrparser;
import javax.swing.*;
import java.util.*;
import lalrgen.*;
/**
 * Ventana que muestra la tabla LALR dada por un paquete.
 * @author  kreig
 */
public class TablaLRFrame extends javax.swing.JFrame {
    LRTableModel lrtablemodel;
    /** Creates new form TablaLRFrame */
    public TablaLRFrame() {
        lrtablemodel = new LRTableModel();
        initComponents();        
    }
    /**Construye la tabla con los datos contenidos en el paquete*/
    public TablaLRFrame(LALRFilePack p) {
        lrtablemodel = new LRTableModel(p);
        initComponents();
    }
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();

        setTitle("Tabla LALR");
        jTable1.setModel(lrtablemodel);
        jScrollPane1.setViewportView(jTable1);

        jLabel1.setText("Indice");

        jLabel2.setText("- Sx: Desplaza y va al estado x.");

        jLabel3.setText("- Ry: Reduce por la produccion y.");

        jLabel4.setText("- Celdas nulas indican error sintactico.");

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 478, Short.MAX_VALUE)
                    .add(jLabel1)
                    .add(layout.createSequentialGroup()
                        .add(12, 12, 12)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jLabel3)
                            .add(jLabel2)
                            .add(jLabel4))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 213, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jLabel1)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jLabel2)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jLabel3)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jLabel4))
        );
        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new TablaLRFrame().setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    // End of variables declaration//GEN-END:variables
    
}

class LRTableModel extends javax.swing.table.AbstractTableModel{
    private lalrgen.LALRFilePack paquete; /**Paquete actual*/
    private Vector<Terminal> t = new Vector<Terminal>(); /**Vector de No Terminales*/
    private Vector<NoTerminal> nt = new Vector<NoTerminal>(); /**Vector de Terminales*/
    private int offsetNT = 0; /**Distancia de inicio para las celdas de los no terminales*/
    public LRTableModel(){
        paquete = new LALRFilePack();        
    }
            
    LRTableModel(lalrgen.LALRFilePack paqueteActual){
        paquete = paqueteActual;/**Asignamos paquete*/
        rellenarSimbolos();
    }
    public void setPaquete(lalrgen.LALRFilePack paqueteActual){
        paquete = paqueteActual;        
        rellenarSimbolos();
    }
    /**Rellena vector de terminales y no terminales con los datos de paquete*/
    private void rellenarSimbolos(){
        t.removeAllElements();
        nt.removeAllElements();
        /**Rellenamos terminales*/
        Collection simbolos = this.paquete.getListaT().values();
        Iterator i = simbolos.iterator();        
        while(i.hasNext()){
            t.add((Terminal) i.next());
        }
        t.add(Vacc.dolar);
        /**Rellenamos no terminales*/
        simbolos = this.paquete.getListaNT().values();
        i = simbolos.iterator();        
        while(i.hasNext()){
            nt.add((NoTerminal) i.next());
        }
        offsetNT = this.t.size() + 1;
    }
    public int getRowCount(){
        return paquete.getNumEstados() + 1;
    }
    public int getColumnCount(){
        return paquete.getListaNT().size() + paquete.getListaT().size() + 2;
        
    }
    
    public Object getValueAt(int row, int column){
        /**devolvemos la columna de indices de estados*/
        TuplaLR clave;
        GoToLR got;
        AccionLR acc;
//        if(column <= getColumnCount() && row <= this.getRowCount()){
//            if(column == 0){
//                if (row > 0)
//                    return new String("S" + (row));
//                else
//                    return null;
//            }
//             /**devolvemos a fila de indices de simbolos*/
//            if(row == 0){
//                if(column < offsetNT)
//                    return t.get(column);
//                else{
//                    return nt.get(column - offsetNT);
//                }
//            }
            /**Devolvemos celda de dato*/
        if(column > 0 && row > 0){
            if(column < offsetNT){
                clave = new TuplaLR(row - 1,t.get(column - 1));
                acc = paquete.getTablaAcciones().get(clave);            
                return acc;

            }
            else{
                clave = new TuplaLR(row - 1,nt.get(column - offsetNT));
                got = paquete.getTablaGoto().get(clave);
                return got;
            }        
        }
        else{
            if(column == 0){
                if (row > 0)
                    return new String("I_" + (row - 1));
                else
                    return null;
            }
             /**devolvemos a fila de indices de simbolos*/
            if(row == 0){
                if(column < offsetNT)
                    return t.get(column - 1);
                else{
                    return nt.get(column - offsetNT);
                }
            }
            return null;
        }
            
    }
}

